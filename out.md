## Authenticated Encryption with Additional Data


Encrypts a message with a key and a nonce to keep it confidential Computes
an authentication tag. This tag is used to make sure that the message, as
well as optional, non-confidential (non-encrypted) data, haven't been
tampered with.

A typical use case for additional data is to store protocol-specific metadata
about the message, such as its length and encoding.

Supported Algorithms:
 * AES-GCM 256: API names use `aes256gcm`
 * ChaCha20-Poly1305: API names use `chacha20poly1305`
 * ChaCha20-Poly1305-IETF: API names use `chacha20poly1305-ietf`

### Modes

#### Combined
 In combined mode, the authentication tag and the encrypted
 message are stored together. Functions return a buffer that includes the
 cipher text and authentication tag.
 Encrypt/Decrypt functions return a buffer with length equal to
 `message_length + crypto_aead_*_ABYTES` bytes.

#### Detached
 In detached mode, the authentication tag and the encrypted
 message in different buffers. Detached function variants are named with the
 `_detached` sufix. Encrypt functions return:

```js
 { cipherText: <buffer>, mac: <buffer> }
```

* `cipherText` *(Buffer)* <span class='dash'>&mdash;</span> encrypted message
* `mac` *(Buffer)* <span class='dash'>&mdash;</span> authentication tag (`crypto_aead_*_ABYTES` long)

### Crypto AEAD AES-GCM 256


The current implementation of this construction is hardware-accelerated and
requires the Intel SSSE3 extensions, as well as the aesni and pclmul
instructions.

Intel Westmere processors (introduced in 2010) and newer meet the requirements.

There are no plans to support non hardware-accelerated implementations of
[AES-GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode).
If portability is a concern, use ChaCha20-Poly1305 instead.

### Low Level API



### Precompute API


Speeding up the encryption/decryption process.
The precompute API breaks down the encrypt/decrypt functions in two stages -
"Before" and "After". The "before" stage is called once, everytime your
application changes encryption keys. The "after" stage is called for every
message you need to encrypt/decrypt.
The functions `*_beforenm` implement the "before" stage, and the `*_afternm`
the "after" stage. They offer the same functionality as their non-precompute
counterparts but take a "state" object generated by the `*_beforenm` instead
of an encryption key.

**Sample**:

```js
var sodium = require('sodium').api;

// Generate a random key
var key = new Buffer(crypto_aead_aes256gcm_KEYBYTES);
sodium.randombytes_buf(key);

// Generate random nonce
var nonce = new Buffer(crypto_aead_aes256gcm_KEYBYTES);
sodium.randombytes_buf(nonce);

// Precompute and generate the state
var state = sodium.crypto_aead_aes256gcm_beforenm(key);

var message = new Buffer("this is a plain text message");
var additionalData = new Buffer("metadata");

// Encrypt Data
var cipherText = sodium.crypto_aead_aes256gcm_encrypt_afternm(
   message, additionalData, nonce, state);

// Get the plain text, i.e., original message back
var plainText = sodium.crypto_aead_aes256gcm_decrypt_afternm(
   cipherText, additionalData, nonce, state);
```

### crypto_aead_aes256gcm_is_available


Check hardware support for AES 256 GCM

**Returns**:

* `true` <span class='dash'>&mdash;</span> if hardware supports AES 256 GCM

**Sample**:

```js
if( sodium.crypto_aead_aes256gcm_is_available() ) {
  // You can use the crypto_aead_aes256gcm_*()
}
else {
  // Use crypto_aead_chacha20poly1305_*()
}
```

### crypto_aead_aes256gcm_beforenm

Precompute AES key expansion.

Applications that encrypt several messages using the same key can gain a
little speed by expanding the AES key only once, via the precalculation interface
Initializes a context ctx by expanding the key k and always returns 0.

```js
var ctx = sodium.crypto_aead_aes256gcm_beforenm(key);
```

* `key` *(Buffer)* <span class='dash'>&mdash;</span>  AES 256 GCM Key buffer with crypto_aead_aes256gcm_KEYBYTES in length

**Sample**:

```js
// Generate a random key
var key = new Buffer(crypto_aead_aes256gcm_KEYBYTES);
sodium.randombytes_buf(key);
var state = sodium.crypto_aead_aes256gcm_beforenm(key);
```

### crypto_aead_aes256gcm_encrypt_afternm

Encrypt data in Combined Mode

```js
 var c = sodium.crypto_aead_aes256gcm_encrypt_afternm(
           message,
           additionalData,
           nonce,
           ctx);
```

* `message` *(Buffer)* <span class='dash'>&mdash;</span> plain text buffer
* `additionalData` *(Buffer)* <span class='dash'>&mdash;</span> non-confidential data to add to the cipher text. Can be `null`
* `nonce` *(Buffer)* <span class='dash'>&mdash;</span> a nonce with `sodium.crypto_aead_aes256gcm_NPUBBYTES` in length
* `ctx` *(Buffer)* <span class='dash'>&mdash;</span> state computed by `crypto_aead_aes256gcm_beforenm()`

**Returns**:

* `cipherText` *(Buffer)* <span class='dash'>&mdash;</span> The encrypted message, as well as a tag authenticating
  both the confidential message `message` and non-confidential data `additionalData`
* `undefined` <span class='dash'>&mdash;</span> if `message` fails to encrypt

### crypto_aead_aes256gcm_decrypt_afternm

Decrypt data in Combined Mode

```js
 var c = sodium.crypto_aead_aes256gcm_decrypt_afternm(
           cipherText,
           additionalData,
           nonce,
           ctx);
```

* `cipherText` *(Buffer)* <span class='dash'>&mdash;</span> cipher text buffer, encrypted by crypto_aead_aes256gcm_encrypt_afternm()
* `additionalData` *(Buffer)* <span class='dash'>&mdash;</span> non-confidential data to add to the cipher text. Can be `null`
* `nonce` *(Buffer)* <span class='dash'>&mdash;</span> a nonce with `sodium.crypto_aead_aes256gcm_NPUBBYTES` in length
* `ctx` *(Buffer)* <span class='dash'>&mdash;</span> state computed by `crypto_aead_aes256gcm_beforenm()`

**Returns**:

* `message` *(Buffer)* <span class='dash'>&mdash;</span> plain text message
* `undefined` <span class='dash'>&mdash;</span> if `cipherText` is not valid

### crypto_aead_aes256gcm_encrypt_detached_afternm

Encrypt data in Detached Mode

```js
 var c = sodium.crypto_aead_aes256gcm_encrypt_detached_afternm(
           message,
           additionalData,
           nonce,
           ctx);
```

* `message` *(Buffer)* <span class='dash'>&mdash;</span> plain text buffer
* `additionalData` *(Buffer)* <span class='dash'>&mdash;</span> non-confidential data to add to the cipher text.
  Can be `null`
* `nonce` *(Buffer)* <span class='dash'>&mdash;</span> a nonce with `sodium.crypto_aead_aes256gcm_NPUBBYTES` in
  length
* `ctx` *(Buffer)* <span class='dash'>&mdash;</span> state computed by `crypto_aead_aes256gcm_beforenm()`

**Returns**:

* `object` <span class='dash'>&mdash;</span> `cipherText` buffer with ciphered text, and `mac` with the
  authentication tag

```js
 { cipherText: <buffer>, mac: <buffer> }
```

* `undefined` <span class='dash'>&mdash;</span> if `message` fails to encrypt

**Sample**:

```js
var sodium = require('sodium').api;

// Generate a random key
var key = new Buffer(crypto_aead_aes256gcm_KEYBYTES);
sodium.randombytes_buf(key);

// Generate random nonce
var nonce = new Buffer(crypto_aead_aes256gcm_KEYBYTES);
sodium.randombytes_buf(nonce);

// Precompute and generate the state
var state = sodium.crypto_aead_aes256gcm_beforenm(key);

var message = new Buffer("this is a plain text message");
var additionalData = new Buffer("metadata");

// Encrypt Data
var c = sodium.crypto_aead_aes256gcm_encrypt_detached_afternm(
   message, additionalData, nonce, state);

// Get the plain text, i.e., original message back
var plainText = sodium.crypto_aead_aes256gcm_decrypt_detached_afternm(
   c.cipherText, c.mac, nonce, state);
```

### crypto_aead_aes256gcm_decrypt_detached_afternm

Encrypt data in Detached Mode

```js
 var c = sodium.crypto_aead_aes256gcm_decrypt_detached_afternm(
           cipherText,
           mac,
           nonce,
           ctx);
```

* `cipherText` *(Buffer)* <span class='dash'>&mdash;</span> cipher text buffer
* `mac` *(Buffer)* <span class='dash'>&mdash;</span> authentication tag. Can be null
* `nonce` *(Buffer)* <span class='dash'>&mdash;</span> a nonce with `sodium.crypto_aead_aes256gcm_NPUBBYTES` in
  length
* `ctx` *(Buffer)* <span class='dash'>&mdash;</span> state computed by `crypto_aead_aes256gcm_beforenm()`

**Returns**:

* `message` *(Buffer)* <span class='dash'>&mdash;</span> plain text message
* `undefined` <span class='dash'>&mdash;</span> if `message` fails to encrypt

See: [crypto_aead_aes256gcm_encrypt_detached_afternm][crypto_aead_aes256gcm_encrypt_detached_afternm]
